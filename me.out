////J:\dev\Jasper\server\src\index.js
const Koa = require("koa");
const Router = require("@koa/router");
const bodyParser = require("koa-bodyparser");
const cors = require("@koa/cors"); // ✅ modern, maintained package
const http = require("http");
const socketIO = require("socket.io");
const fileRoutes = require("./routes/files");

const app = new Koa();
const router = new Router();

const allowedOrigins = [
  "localhost:3000",
  "localhost:4000",
  // "http://localhost:3000",
  // "http://localhost:4000",
  // "http://192.168.1.100:3000",
  // "http://192.168.1.101:3000",
  // "http://192.168.1.102:3000",
];

// Middleware
app.use(bodyParser());

app.use(
  cors({
    origin: (origin, ctx) => {
      console.log("CORS request from origin:", origin.host);

      // Allow requests with no origin (e.g., curl, mobile apps)
      if (!origin) return "*";

      if (allowedOrigins.includes(origin?.request?.header?.host)) {
        console.log("✔️ Allowed origin:", origin);
        return origin;
      }

      console.log("❌ Not allowed origin V2:", origin, allowedOrigins, origin);
      return ""; // Returning empty string blocks the request
    },
    credentials: true,
  })
);
//router.use("api/files", fileRoutes.routes());
router.use("files", fileRoutes.routes());

// Routes
router.get("/api/health", (ctx) => {
  ctx.body = { status: "ok" };
});

router.get("/routes", async (ctx) => {
  const routes = router.stack.map((layer) => ({
    method: layer.methods.join("|"),
    path: layer.path,
    name: layer.name || undefined, // Optional route name
  }));
  ctx.body = routes;
});

const messages = [];

router.get("/api/messages", (ctx) => {
  ctx.body = messages;
});

router.get("/api/clear", (ctx) => {
  messages.length = 0;
  ctx.body = messages;
});

// Apply router middleware
app.use(router.routes());
app.use(router.allowedMethods());

// Create HTTP server
const server = http.createServer(app.callback());

// Setup Socket.IO with CORS
const io = socketIO(server, {
  cors: {
    origin: (origin, callback) => {
      console.log("Socket.IO CORS request from:", origin);
      //if (!origin || allowedOrigins.includes(origin)) {
      if (!origin) {
        callback(null, true);
      } else {
        callback(new Error("Not allowed by Socket.IO CORS"));
      }
    },
    credentials: true,
    methods: ["GET", "POST"],
  },
});

// Socket.IO connection handler
io.on("connection", (socket) => {
  console.log("🔌 New client connected");

  // Send existing messages
  socket.emit("initial messages", messages);

  socket.on("new message", (message) => {
    const newMessage = {
      id: Date.now(),
      text: message.text,
      user: message.user,
      timestamp: new Date(),
    };

    messages.push(newMessage);
    console.log("new message: " + newMessage.text);
    io.emit("new message", newMessage);
  });

  socket.on("disconnect", () => {
    console.log("🚫 Client disconnected");
  });
});

// Start server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`🚀 Server running on http://localhost:${PORT}`);
});

////J:\dev\Jasper\server\src\routes\files.js
const Router = require("@koa/router");
const fs = require("fs").promises;
const path = require("path");

const router = new Router();

// Helper: sanitize and resolve full path
function resolveFullPath(base, relativePath = "") {
  const safePath = path.normalize(relativePath).replace(/^(\.\.(\/|\\|$))+/, "");
  return path.join(base, safePath);
}

//const ROOT_DIR = path.resolve(__dirname, "../your-root-directory");
const ROOT_DIR = path.resolve(__dirname, "../");

// Route: GET /files/*path - List folders and files in directory
router.get("(.*)", async (ctx) => {
  const subPath = ctx.params[0] || "";
  const fullPath = resolveFullPath(ROOT_DIR, subPath);

  try {
    const dirContents = await fs.readdir(fullPath, { withFileTypes: true });
    const files = dirContents.filter((d) => d.isFile()).map((f) => f.name);
    const folders = dirContents.filter((d) => d.isDirectory()).map((f) => f.name);

    ctx.body = { path: subPath, folders, files };
  } catch (err) {
    ctx.status = 400;
    ctx.body = { error: "Invalid path or permission denied", details: err.message };
  }
});

// Route: POST /files/rename/*path - Rename a single file
router.post("/rename/(.*)", async (ctx) => {
  const subPath = ctx.params[0] || "";
  const { oldName, newName } = ctx.request.body;
  const dirPath = resolveFullPath(ROOT_DIR, subPath);

  try {
    const oldPath = path.join(dirPath, oldName);
    const newPath = path.join(dirPath, newName);

    await fs.rename(oldPath, newPath);
    ctx.body = { success: true, message: "File renamed successfully" };
  } catch (err) {
    ctx.status = 500;
    ctx.body = { error: "Rename failed", details: err.message };
  }
});

// Route: POST /files/rename-multiple/*path - Rename multiple files
router.post("/rename-multiple/(.*)", async (ctx) => {
  const subPath = ctx.params[0] || "";
  const { renames } = ctx.request.body; // expects array of { oldName, newName }
  const dirPath = resolveFullPath(ROOT_DIR, subPath);

  try {
    for (const { oldName, newName } of renames) {
      const oldPath = path.join(dirPath, oldName);
      const newPath = path.join(dirPath, newName);
      await fs.rename(oldPath, newPath);
    }
    ctx.body = { success: true, message: "Files renamed successfully" };
  } catch (err) {
    ctx.status = 500;
    ctx.body = { error: "Bulk rename failed", details: err.message };
  }
});

module.exports = router;

